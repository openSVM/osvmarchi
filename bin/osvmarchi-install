#!/bin/bash

# OSVMarchi System Installer
# Full system installation with GUI disk partitioning

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Logging functions
log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Check if running on Arch Linux live environment
check_live_environment() {
    if [[ ! -f /etc/arch-release ]]; then
        log_error "This installer must be run on Arch Linux"
        exit 1
    fi
    
    # Check if we're in a live environment (multiple detection methods)
    local is_live=false
    
    # Method 1: Check for archiso
    if [[ -d /run/archiso ]] || [[ -f /run/archiso/bootmnt/arch/boot/x86_64/vmlinuz-linux ]]; then
        is_live=true
    fi
    
    # Method 2: Check for live boot indicator
    if grep -q "archisobasedir" /proc/cmdline 2>/dev/null; then
        is_live=true
    fi
    
    # Method 3: Check if root filesystem is tmpfs/overlay
    if mount | grep -q "/ type tmpfs\|/ type overlay"; then
        is_live=true
    fi
    
    if [[ "$is_live" != "true" ]]; then
        log_warning "Not detected as Arch Linux live environment"
        log_warning "This installer is designed for live environments"
        log_warning "Running on installed systems may cause data loss!"
        if ! gum confirm "Continue anyway? (NOT RECOMMENDED)"; then
            exit 1
        fi
    fi
}

# Check prerequisites
check_prerequisites() {
    local missing_tools=()
    
    for tool in gparted gum; do
        if ! command -v "$tool" &>/dev/null; then
            missing_tools+=("$tool")
        fi
    done
    
    if [[ ${#missing_tools[@]} -gt 0 ]]; then
        log_error "Missing required tools: ${missing_tools[*]}"
        log_info "Installing missing tools..."
        pacman -Sy --noconfirm "${missing_tools[@]}"
    fi
}

# Detect available disks
detect_disks() {
    log_info "Detecting available disks..."
    
    # Get list of block devices that are disks (not partitions)
    local disks
    if ! mapfile -t disks < <(lsblk -dpno NAME,SIZE,MODEL | grep -E '^/dev/(sd|nvme|vd|hd)[a-z]' | head -10); then
        log_error "Failed to detect disks using lsblk"
        exit 1
    fi
    
    # Filter out removable devices (USB drives) unless explicitly requested
    local filtered_disks=()
    for disk_line in "${disks[@]}"; do
        local disk_path=$(echo "$disk_line" | awk '{print $1}')
        local disk_name=$(basename "$disk_path")
        
        # Check if disk is removable
        local removable="0"
        if [[ -f "/sys/block/$disk_name/removable" ]]; then
            removable=$(cat "/sys/block/$disk_name/removable")
        fi
        
        # Include non-removable disks or warn about removable ones
        if [[ "$removable" == "0" ]]; then
            filtered_disks+=("$disk_line")
        else
            log_warning "Skipping removable device: $disk_path"
        fi
    done
    
    # Use filtered disks or fall back to all disks if none found
    if [[ ${#filtered_disks[@]} -eq 0 ]]; then
        log_warning "No non-removable disks found, showing all available disks"
        filtered_disks=("${disks[@]}")
    fi
    
    if [[ ${#filtered_disks[@]} -eq 0 ]]; then
        log_error "No suitable disks found for installation"
        log_info "Available block devices:"
        lsblk -f
        exit 1
    fi
    
    log_info "Found ${#filtered_disks[@]} suitable disk(s):"
    printf '%s\n' "${filtered_disks[@]}"
    echo
}

# Interactive disk selection and partitioning
partition_disk() {
    log_info "Starting disk partitioning..."
    
    # Detect disks first
    detect_disks
    
    # Get list of disks for selection
    local disk_choices=()
    while IFS= read -r line; do
        if [[ $line =~ ^(/dev/[^[:space:]]+) ]]; then
            disk_choices+=("${BASH_REMATCH[1]}")
        fi
    done < <(lsblk -dpno NAME,SIZE,MODEL | grep -E '^/dev/(sd|nvme|vd)[a-z]')
    
    if [[ ${#disk_choices[@]} -eq 0 ]]; then
        log_error "No disks available for selection"
        exit 1
    fi
    
    # Let user choose disk
    local selected_disk
    if [[ ${#disk_choices[@]} -eq 1 ]]; then
        selected_disk="${disk_choices[0]}"
        log_info "Only one disk available: $selected_disk"
        if ! gum confirm "Use $selected_disk for installation?"; then
            log_error "Installation cancelled"
            exit 1
        fi
    else
        log_info "Multiple disks found. Please select one:"
        selected_disk=$(printf '%s\n' "${disk_choices[@]}" | gum choose --header="Select disk for OSVMarchi installation:")
    fi
    
    log_info "Selected disk: $selected_disk"
    
    # Warn about data loss
    log_warning "WARNING: All data on $selected_disk will be DESTROYED!"
    log_warning "This action cannot be undone!"
    
    if ! gum confirm "Are you absolutely sure you want to continue?"; then
        log_error "Installation cancelled"
        exit 1
    fi
    
    # Offer partitioning options
    local partition_method
    partition_method=$(echo -e "Automatic (Recommended)\nManual (GParted)" | gum choose --header="Choose partitioning method:")
    
    case "$partition_method" in
        "Automatic (Recommended)")
            automatic_partition "$selected_disk"
            ;;
        "Manual (GParted)")
            manual_partition "$selected_disk"
            ;;
    esac
    
    echo "$selected_disk"
}

# Automatic partitioning for UEFI systems
automatic_partition() {
    local disk="$1"
    log_info "Creating automatic UEFI partition layout on $disk..."
    
    # Check if system is UEFI
    if [[ ! -d /sys/firmware/efi ]]; then
        log_error "Automatic partitioning currently only supports UEFI systems"
        log_info "Please use manual partitioning for BIOS systems"
        exit 1
    fi
    
    # Unmount any existing partitions
    umount "${disk}"* 2>/dev/null || true
    
    # Wipe disk
    log_info "Wiping disk $disk..."
    wipefs -a "$disk"
    sgdisk --zap-all "$disk"
    
    # Create GPT partition table and partitions
    log_info "Creating partition table..."
    sgdisk --clear \
           --new=1:0:+1G --typecode=1:ef00 --change-name=1:'EFI System' \
           --new=2:0:0 --typecode=2:8300 --change-name=2:'OSVMarchi Root' \
           "$disk"
    
    # Re-read partition table
    partprobe "$disk"
    sleep 2
    
    # Determine partition names (handle nvme vs sda naming)
    local boot_part root_part
    if [[ $disk =~ nvme ]]; then
        boot_part="${disk}p1"
        root_part="${disk}p2"
    else
        boot_part="${disk}1"
        root_part="${disk}2"
    fi
    
    # Format partitions
    log_info "Formatting EFI partition..."
    mkfs.fat -F 32 -n "EFI" "$boot_part"
    
    log_info "Formatting root partition..."
    mkfs.ext4 -L "OSVMarchi" "$root_part"
    
    # Export partition variables for later use
    export OSVMARCHI_BOOT_PART="$boot_part"
    export OSVMARCHI_ROOT_PART="$root_part"
    
    log_success "Automatic partitioning complete"
}

# Manual partitioning with GParted
manual_partition() {
    local disk="$1"
    log_info "Opening GParted for manual partitioning of $disk..."
    
    log_info "Please create the following partitions:"
    log_info "1. EFI System Partition (512MB-1GB, FAT32, esp flag)"
    log_info "2. Root partition (remaining space, ext4 or btrfs)"
    log_info ""
    log_info "Press Enter when ready to open GParted..."
    read -r
    
    # Launch GParted
    gparted "$disk"
    
    log_info "GParted closed. Please specify the created partitions:"
    
    # Get available partitions for this disk
    local partitions
    mapfile -t partitions < <(lsblk -pno NAME "$disk" | grep -E "${disk}[p]?[0-9]+")
    
    if [[ ${#partitions[@]} -lt 2 ]]; then
        log_error "At least 2 partitions required (EFI + Root)"
        exit 1
    fi
    
    # Let user select partitions
    local boot_part root_part
    boot_part=$(printf '%s\n' "${partitions[@]}" | gum choose --header="Select EFI/Boot partition:")
    root_part=$(printf '%s\n' "${partitions[@]}" | gum choose --header="Select Root partition:")
    
    if [[ "$boot_part" == "$root_part" ]]; then
        log_error "Boot and root partitions cannot be the same"
        exit 1
    fi
    
    # Export partition variables for later use
    export OSVMARCHI_BOOT_PART="$boot_part"
    export OSVMARCHI_ROOT_PART="$root_part"
    
    log_success "Manual partitioning complete"
    log_info "Boot partition: $boot_part"
    log_info "Root partition: $root_part"
}

# Mount partitions and install base system
install_base_system() {
    local root_part="$OSVMARCHI_ROOT_PART"
    local boot_part="$OSVMARCHI_BOOT_PART"
    
    log_info "Mounting partitions..."
    
    # Mount root
    mount "$root_part" /mnt
    
    # Create and mount boot
    mkdir -p /mnt/boot
    mount "$boot_part" /mnt/boot
    
    log_info "Installing base Arch Linux system..."
    
    # Install base system
    pacstrap /mnt base base-devel linux linux-firmware \
        networkmanager sudo git gum curl wget \
        efibootmgr dosfstools e2fsprogs btrfs-progs
    
    # Generate fstab
    log_info "Generating fstab..."
    genfstab -U /mnt >> /mnt/etc/fstab
    
    log_success "Base system installation complete"
}

# Configure base system
configure_base_system() {
    log_info "Configuring base system..."
    
    # Chroot configuration script
    cat > /mnt/configure_system.sh << 'EOF'
#!/bin/bash
set -e

# Set timezone
ln -sf /usr/share/zoneinfo/UTC /etc/localtime
hwclock --systohc

# Configure locale
echo "en_US.UTF-8 UTF-8" >> /etc/locale.gen
locale-gen
echo "LANG=en_US.UTF-8" > /etc/locale.conf

# Set hostname
echo "osvmarchi" > /etc/hostname

# Configure hosts
cat >> /etc/hosts << EOL
127.0.0.1   localhost
::1         localhost
127.0.1.1   osvmarchi.localdomain osvmarchi
EOL

# Enable NetworkManager
systemctl enable NetworkManager

# Install and configure bootloader (systemd-boot)
bootctl install

# Create bootloader entry
mkdir -p /boot/loader/entries
cat > /boot/loader/entries/arch.conf << EOL
title   OSVMarchi
linux   /vmlinuz-linux
initrd  /initramfs-linux.img
options root=PARTUUID=$(blkid -s PARTUUID -o value ${OSVMARCHI_ROOT_PART}) rw quiet splash
EOL

cat > /boot/loader/loader.conf << EOL
default arch.conf
timeout 3
console-mode max
editor no
EOL

# Create user
useradd -m -G wheel -s /bin/bash user
echo "user:user" | chpasswd

# Configure sudo
echo "%wheel ALL=(ALL:ALL) ALL" >> /etc/sudoers

# Set root password
echo "root:root" | chpasswd

echo "Base system configuration complete"
EOF

    # Make script executable and run it
    chmod +x /mnt/configure_system.sh
    arch-chroot /mnt /configure_system.sh
    rm /mnt/configure_system.sh
    
    log_success "Base system configuration complete"
}

# Install OSVMarchi in chroot
install_osvmarchi() {
    log_info "Installing OSVMarchi..."
    
    # Create OSVMarchi installation script for chroot
    cat > /mnt/install_osvmarchi.sh << 'EOF'
#!/bin/bash
set -e

# Switch to user account for OSVMarchi installation
sudo -u user bash << 'USEREOF'
cd /home/user

# Download and install OSVMarchi
curl -fsSL https://raw.githubusercontent.com/openSVM/osvmarchi/master/boot.sh | bash

USEREOF

echo "OSVMarchi installation complete"
EOF

    # Make script executable and run it
    chmod +x /mnt/install_osvmarchi.sh
    arch-chroot /mnt /install_osvmarchi.sh
    rm /mnt/install_osvmarchi.sh
    
    log_success "OSVMarchi installation complete"
}

# Main installation function
main() {
    log_info "Starting OSVMarchi installation..."
    
    # Check prerequisites
    check_live_environment
    check_prerequisites
    
    # Partition disk
    local selected_disk
    selected_disk=$(partition_disk)
    
    # Install base system
    install_base_system
    
    # Configure base system
    configure_base_system
    
    # Install OSVMarchi
    install_osvmarchi
    
    # Cleanup
    log_info "Cleaning up..."
    umount -R /mnt
    
    log_success "OSVMarchi installation completed successfully!"
    log_info "You can now reboot into your new OSVMarchi system"
    log_info "Default login: user/user (change password after first login)"
    
    if gum confirm "Reboot now?"; then
        reboot
    fi
}

# Show usage help
show_help() {
    cat << EOF
OSVMarchi System Installer

This script installs OSVMarchi on a fresh disk with automatic or manual partitioning.

USAGE:
    $0 [OPTIONS]

OPTIONS:
    -h, --help      Show this help message
    -t, --test      Test mode (validation only, no installation)

REQUIREMENTS:
    - Arch Linux live environment (ISO)
    - UEFI system (for automatic partitioning)
    - Internet connection
    - Target disk with sufficient space (20GB+ recommended)

FEATURES:
    - Automatic UEFI partitioning with sensible defaults
    - Manual partitioning with GParted GUI
    - Base Arch Linux installation
    - Full OSVMarchi configuration
    - Bootloader setup

PARTITIONING:
    Automatic mode creates:
    - 1GB EFI System Partition (FAT32)
    - Remaining space for root (ext4)
    
    Manual mode allows custom partition layouts with GParted.

EXAMPLES:
    $0                  # Start interactive installation
    $0 --test          # Test disk detection and validation only
    $0 --help          # Show this help

EOF
}

# Test mode - validation only
test_mode() {
    log_info "Running OSVMarchi installer in test mode..."
    
    # Run all checks without actual installation
    log_info "Testing live environment detection..."
    if [[ ! -f /etc/arch-release ]]; then
        log_error "Not running on Arch Linux"
    else
        log_success "Arch Linux detected"
    fi
    
    log_info "Testing prerequisite tools..."
    local missing_tools=()
    for tool in gparted gum lsblk; do
        if command -v "$tool" &>/dev/null; then
            log_success "$tool: Available"
        else
            log_warning "$tool: Missing"
            missing_tools+=("$tool")
        fi
    done
    
    log_info "Testing disk detection..."
    detect_disks
    
    log_info "Testing partition detection..."
    local disk_choices=()
    while IFS= read -r line; do
        if [[ $line =~ ^(/dev/[^[:space:]]+) ]]; then
            disk_choices+=("${BASH_REMATCH[1]}")
        fi
    done < <(lsblk -dpno NAME,SIZE,MODEL | grep -E '^/dev/(sd|nvme|vd|hd)[a-z]')
    
    log_info "Available disks for installation:"
    printf '  %s\n' "${disk_choices[@]}"
    
    if [[ ${#missing_tools[@]} -eq 0 ]]; then
        log_success "All tests passed! System ready for installation."
    else
        log_warning "Some tools missing: ${missing_tools[*]}"
        log_info "Run 'pacman -S ${missing_tools[*]}' to install missing tools"
    fi
    
    log_info "Test mode completed. Use '$0' (without --test) to start actual installation."
}

# Parse command line arguments
case "${1:-}" in
    -h|--help)
        show_help
        exit 0
        ;;
    -t|--test)
        test_mode
        exit 0
        ;;
    "")
        main
        ;;
    *)
        log_error "Unknown option: $1"
        echo "Use '$0 --help' for usage information"
        exit 1
        ;;
esac